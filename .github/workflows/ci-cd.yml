name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      bot-service: ${{ steps.changes.outputs.bot-service }}
      user-service: ${{ steps.changes.outputs.user-service }}
      admin-ui: ${{ steps.changes.outputs.admin-ui }}
      client-ui: ${{ steps.changes.outputs.client-ui }}
      bazel-config: ${{ steps.changes.outputs.bazel-config }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            bot-service:
              - 'api/bot_service/**'
            user-service:
              - 'api/user_service/**'
            admin-ui:
              - 'ui/admin_ui/**'
            client-ui:
              - 'ui/client_ui/**'
            bazel-config:
              - 'WORKSPACE'
              - '.bazelrc'
              - '**/BUILD'
              - 'platforms/**'

  setup-bazel:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.bazel-config == 'true' || needs.detect-changes.outputs.bot-service == 'true' || needs.detect-changes.outputs.user-service == 'true' || needs.detect-changes.outputs.admin-ui == 'true' || needs.detect-changes.outputs.client-ui == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Skip Bazel setup
        run: |
          echo "Bazel setup skipped - using Docker builds instead"
          echo "This avoids GitHub Actions cache service issues"

  lint-and-test:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-bazel]
    if: needs.detect-changes.outputs.bot-service == 'true' || needs.detect-changes.outputs.user-service == 'true' || needs.detect-changes.outputs.admin-ui == 'true' || needs.detect-changes.outputs.client-ui == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Skip Bazel lint and test
        run: |
          echo "Bazel linting and testing skipped - using Docker builds instead"
          echo "Individual service tests and linting handled in Docker build process"

  build-bot-service:
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-test]
    if: needs.detect-changes.outputs.bot-service == 'true' || needs.detect-changes.outputs.bazel-config == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Build and push Bot Service
        uses: docker/build-push-action@v4
        with:
          context: ./api/bot_service
          file: ./api/bot_service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-bot-service:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-bot-service:${{ github.sha }}

  build-user-service:
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-test]
    if: needs.detect-changes.outputs.user-service == 'true' || needs.detect-changes.outputs.bazel-config == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Build and push User Service
        uses: docker/build-push-action@v4
        with:
          context: ./api/user_service
          file: ./api/user_service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-user-service:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-user-service:${{ github.sha }}

  build-admin-ui:
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-test]
    if: needs.detect-changes.outputs.admin-ui == 'true' || needs.detect-changes.outputs.bazel-config == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Build and push Admin UI
        uses: docker/build-push-action@v4
        with:
          context: ./ui/admin_ui
          file: ./ui/admin_ui/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-admin-ui:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-admin-ui:${{ github.sha }}

  build-client-ui:
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-test]
    if: needs.detect-changes.outputs.client-ui == 'true' || needs.detect-changes.outputs.bazel-config == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Build and push Client UI
        uses: docker/build-push-action@v4
        with:
          context: ./ui/client_ui
          file: ./ui/client_ui/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-client-ui:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-client-ui:${{ github.sha }}

  deploy-to-vps:
    needs: [detect-changes, build-bot-service, build-user-service, build-admin-ui, build-client-ui]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass
      
      - name: Connect to VPS and deploy
        run: |
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no pressnave@${{ secrets.VPS_HOST }} << EOF
            # Set up sparse checkout directory
            DEPLOY_DIR="/home/pressnave/ChatAppointment-Deploy"
            
            # Remove existing directory and create fresh sparse checkout
            rm -rf \$DEPLOY_DIR
            mkdir -p \$DEPLOY_DIR
            cd \$DEPLOY_DIR
            
            # Initialize git and configure sparse checkout
            git init
            git remote add origin ${{ github.server_url }}/${{ github.repository }}.git
            git config core.sparseCheckout true
            
            # Configure sparse checkout to only include k8s and scripts
            echo "k8s/*" > .git/info/sparse-checkout
            echo "scripts/*" >> .git/info/sparse-checkout
            
            # Pull only the required files
            git pull origin main
            
            # Make scripts executable
            chmod +x scripts/*.sh
            
            # Set up environment
            export KUBECONFIG=/home/pressnave/.kube/config
            
            # Check if Minikube is running
            if ! minikube status > /dev/null 2>&1; then
              echo "Starting Minikube..."
              minikube start --cpus=4 --memory=4096 --disk-size=20g
            fi
            
            # Login to Docker Hub and pull images
            echo "Logging into Docker Hub..."
            echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
            
            # Pull Docker images from Docker Hub
            echo "Pulling Docker images from Docker Hub..."
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-bot-service:latest
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-user-service:latest  
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-admin-ui:latest
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-client-ui:latest
            
            # Tag images for Kubernetes deployment (local names)
            docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-bot-service:latest chat-appointment/bot-service:latest
            docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-user-service:latest chat-appointment/user-service:latest
            docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-admin-ui:latest chat-appointment/admin-ui:latest
            docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/chat-appointment-client-ui:latest chat-appointment/client-ui:latest
            
            # Verify images are available
            echo "Verifying Docker images:"
            docker images | grep chat-appointment
            
            # Deploy to Kubernetes
            echo "Deploying to Kubernetes..."
            kubectl apply -f k8s/
            
            # Wait for deployments to be ready
            echo "Waiting for deployments..."
            kubectl wait --for=condition=available deployment --all -n chat-appointment --timeout=600s
            
            # Verify SSL configuration
            if kubectl get secret cloudflare-ssl-cert -n chat-appointment > /dev/null 2>&1; then
              echo "SSL certificate found - HTTPS enabled"
            else
              echo "SSL certificate not found - using HTTP"
            fi
            
            # Logout from Docker Hub
            docker logout
            
            echo "Deployment completed successfully!"
          EOF
      
      - name: Run health checks on VPS
        run: |
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no pressnave@${{ secrets.VPS_HOST }} << 'EOF'
            export KUBECONFIG=/home/pressnave/.kube/config
            
            echo "Running health checks..."
            
            # Get Minikube IP
            MINIKUBE_IP=$(minikube ip)
            echo "Minikube IP: $MINIKUBE_IP"
            
            # Test health endpoints
            echo "Testing User Service health..."
            kubectl exec deployment/user-service -n chat-appointment -- curl -f http://localhost:3000/health || {
              echo "User service health check failed"
              exit 1
            }
            
            echo "Testing Bot Service health..."
            kubectl exec deployment/bot-service -n chat-appointment -- curl -f http://localhost:8000/health || {
              echo "Bot service health check failed"
              exit 1
            }
            
            echo "All health checks passed!"
            
            # Show deployment status
            echo "=== Deployment Status ==="
            kubectl get all -n chat-appointment
            
            echo "=== Access URLs ==="
            echo "Client UI: http://pressnavek-appointment-app.gromosome.com"
            echo "Admin UI: http://admin-pressnavek-appointment-app.gromosome.com"
            echo "API: http://api-pressnavek-appointment-app.gromosome.com"
          EOF
      
      - name: Setup domain routing (if needed)
        run: |
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no pressnave@${{ secrets.VPS_HOST }} << 'EOF'
            # Check if hosts entries exist for domain routing
            if ! grep -q "pressnavek-appointment-app.gromosome.com" /etc/hosts 2>/dev/null; then
              echo "Setting up local domain routing..."
              ./scripts/setup-hosts.sh
            else
              echo "Domain routing already configured"
            fi
          EOF
      
      - name: Cleanup on failure
        if: failure()
        run: |
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no pressnave@${{ secrets.VPS_HOST }} << 'EOF'
            export KUBECONFIG=/home/pressnave/.kube/config
            
            echo "Deployment failed. Getting debug information..."
            
            echo "=== Pod Status ==="
            kubectl get pods -n chat-appointment
            
            echo "=== Pod Logs ==="
            kubectl logs -l app=bot-service -n chat-appointment --tail=50 || true
            kubectl logs -l app=user-service -n chat-appointment --tail=50 || true
            kubectl logs -l app=admin-ui -n chat-appointment --tail=50 || true
            kubectl logs -l app=client-ui -n chat-appointment --tail=50 || true
            
            echo "=== Events ==="
            kubectl get events -n chat-appointment --sort-by='.lastTimestamp' || true
          EOF